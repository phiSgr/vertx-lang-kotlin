@includeNamed{'/vertx-java/template/common-lib.templ'}
@code{skipFile=true}

@code{

  def fixMappedCollectionTypes(name) {
    if(name == 'java.util.Iterator') {
      return 'MutableIterator';
    } else if(name == 'java.util.Iterable') {
      return 'MutableIterable';
    } else if(name == 'java.util.Collection') {
      return 'MutableCollection';
    } else if(name == 'java.util.Set') {
      return 'MutableSet';
    } else if(name == 'java.util.List') {
      return 'MutableList';
    } else if(name == 'java.util.ListIterator') {
      return 'MutableListIterator';
    } else if(name == 'java.util.Map') {
      return 'MutableMap';
    } else if(name == 'java.util.Map.Entry') {
      return 'MutableMap.MutableEntry';
    } else {
      return name;
    }
  }

  def fixParameterizedType(type) {
    var mappedArgs = (mapKotlinType($) in type.args);
    return fixMappedCollectionTypes(type.raw.name) + typeParamsToString(mappedArgs);
  }

  def mapKotlinType(type) {
    if (type.name == 'void' || type.name == 'java.lang.Void') {
      return 'Unit';
    } else if (type.name == 'Object' || type.name == 'java.lang.Object') {
      ret = 'Any';
    } else if (type.name == 'Throwable' || type.name == 'java.lang.Throwable') {
      ret = 'Throwable';
    } else if (type.kind == CLASS_STRING) {
      ret = 'String';
    } else if (type.kind == CLASS_PRIMITIVE || type.kind == CLASS_BOXED_PRIMITIVE) {
      if (type.name == 'byte' || type.name == 'java.lang.Byte') {
        ret = 'Byte';
      } else if (type.name == 'short' || type.name == 'java.lang.Short') {
        ret = 'Short';
      } else if (type.name == 'int' || type.name == 'java.lang.Integer') {
        ret = 'Int';
      } else if (type.name == 'long' || type.name == 'java.lang.Long') {
        ret = 'Long';
      } else if (type.name == 'float' || type.name == 'java.lang.Float') {
        ret = 'Float';
      } else if (type.name == 'double' || type.name == 'java.lang.Double') {
        ret = 'Double';
      } else if (type.name == 'boolean' || type.name == 'java.lang.Boolean') {
        ret = 'Boolean';
      } else if (type.name == 'char' || type.name == 'java.lang.Character') {
        ret = 'Char';
      }
    } else if (type.getClass == io.vertx.codegen.type.ParameterizedTypeInfo) {
      ret = fixParameterizedType(type);
    } else {
      ret = type.name;
    }
    return ret + (type.isNullable ? "?" : "");
  }

  def mapToNameTypePair(params) {
    return ($.name + ": " + mapKotlinType($.type) + (isNullable ? "?" : "") in params);
  }

  def paramsToString(params) {
    return String.join(", ", mapToNameTypePair(params));
  }

  def typeParamsToString(typeParams) {
    return "<" + String.join(", ", typeParams) + ">";
  }


  def typeParamsDef(typeParams) {
    return "<" + String.join(", ", ($ + " : Any" in typeParams)) + ">";
  }

  def returnTypeAndBody(handler, body) {
    var handlerType = handler.type;
    assert handlerType.kind == CLASS_HANDLER;
    var typeParam = handlerType.getArgs()[0];
    assert typeParam.kind == CLASS_ASYNC_RESULT;
    var returnType = typeParam.getArgs()[0];

    if (returnType.kind == CLASS_VOID) {
      return " {\n  awaitResult<Void?> " + body + "\n}"
    } else {
      return ": " + mapKotlinType(returnType) + " {\n  return awaitResult " + body + "\n}";
    };
  }

  def genCoroutineMethod(interfaceName, method) {
    var params = method.params;
    var realParams = params.subList(0, params.size() - 1);
    var paramsInWrappedFunctionCall = (name in realParams) + ["it"];
    var typeParamsString = method.typeParams.isEmpty() ? "" : (typeParamsDef((name in method.typeParams)) + " ");
    return "suspend fun " + typeParamsString + interfaceName + "." + method.name +
      "(" + paramsToString(realParams) + ")" + returnTypeAndBody(params[params.size() -1],
        "{ this." + method.name + "(" + String.join(", ", paramsInWrappedFunctionCall) + ") }"
      );
  }

}

package @{type.raw.translatePackageName("kotlin")}\n\n
import io.vertx.kotlin.coroutines.awaitResult\n

@foreach{method:methods}

@if{method.kind == METHOD_FUTURE}

@code{skipFile=false}
\n@{genCoroutineMethod(type.raw.name, method)}\n

@end{}

@end{}
